-- Монады
-- Можно поискать рассказ о теории категорий для программистов

-- Функторы
-- Фунция `map` была бы логична не только для списков. Как бы она работала для Maybe?

f x = x + 1

x1 = Just 42
x2 = Nothing

-- хочу применить f к x1, x2, точнее, к значению внутри
-- maybeMap f x1  ->  Just 43
-- maybeMap f x2  ->  Nothing

maybeMap fun (Just n) = Just (fun n)
maybeMap _ Nothing = Nothing

-- print $ maybeMap f x1 --> (Just 43)
-- print $ maybeMap f x2 --> (Nothing)


-- Допустим, я хочу уметь так же применять функции ко вторым элементам пары:

f x = x + 1
x1 = ("hello", 42)
x2 = ([1, 2, 3], 42.0)

-- хочу применить f ко второму элементу пары

pairMap fun (x, y) = (x, fun y)

-- print $ maybeMap f x1 --> ("hello", 43)
-- print $ maybeMap f x2 --> ([1, 2, 3], 43.0)


-- Есть и другие аналогичные ситуации. Когда значение (или значения) хранятся в какой-то структуре
-- с дополнительными данными.
-- Список - несколько значений и информация об их порядке.
-- Maybe - одно значение или ноль.
-- Пара - значение вместе с дополнительной информацией.

-- Функции тоже можно понимать как такие структуры:
-- fun :: a -> b
-- получается, функция хранит значения типа b, доступ к которым осуществляется по аргументу типа a:
-- Например, 
-- f 1 = "один"
-- f 2 = "два"
-- Функция "хранит" внутри себя значения "один", "два", получить их можно, подставив соответсвующий аргумент в функцию.

f x = x + 1
x1 = \x -> 2 * x
x2 = \x -> 3 * x
-- funMap f x1 - должна получиться функция, которая совпадае с x1, но после применения x1
-- дополнительно вызовет f

funMap fun x = \t -> fun (x t)
xx1 = funMap f x1
xx2 = funMap f x2

-- print $ xx1 42 --> 85
-- print $ xx2 42 --> 127

-- На самом деле все эти map функции уже есть. Они называются fmap или <$>, и они делают ровно то же самое, что делаем мы:

-- print $ fmap (+1) (Just 42) --> Just 43
-- print $ (+1) <$> Just 42 --> Just 43
-- print $ (+1) <$> [10, 20, 30] --> [11, 21, 31]
-- print $ (+1) <$> ("abc", 123) --> ("abc", 124)

-- Это работает, потому что в Haskell есть класс типов Functor - функтор. Он определён так:
class Functor' f where
  fmap' :: (a -> b) -> f a -> f b

-- У него есть реализации, например, так выглядит реализация для Maybe:
instance Functor Maybe where
  fmap f (Just x) = (Just f x)
  fnap _ Nothing = Nothing

-- Если вы определяете функтор, вы должны гаранитровать выполнение следующего правила
-- Функция `id` - это функция, которая ничего не делает: id x = x, её типа a -> a.
-- Правила - как взаимодействует fmap и id
-- 1. fmap id x == x (или эквивалентно) fmap id = id
-- 2. fmap (g . f) == fmap g . fmap f


-- Аппликативные функторы

-- Расширение обычных функторов дополнительными операциями. Представьте опять же Maybe.
-- Было в функторах:
-- 1. Обычная функция
-- 2. Данные внутри структуры
-- 3. Применяем функцию к каждому данному внутри структуры

-- Теперь в аппликативных функторах можно дополнительно
-- 1. Обычные функции внутри структуры
-- 2. Данные внутри структуры
-- 3. Применяем функции из структуры к данным. Как именно применять - очень сильно зависит от ситуации.

-- Пример с Maybe.
f = Just (+1) -- инкремент внутри Maybe
x = Just 42 -- значение внутри Maybe

-- применение:
maybeApply (Just fun) (Just x) == Just (fun x)
maybeApply _ _ = Nothing

-- print $ maybeApply f x --> Just 43
-- print $ maybeApply Nothing x --> Nothing
-- print $ maybeApply (Just (*2)) Nothing --> Nothing

-- А для списков?

f = [(+1), (*2)]
x = [10, 20, 30]

-- что может означать listApply, когда есть список функций и список значений?
-- применить каждую функцию к каждому элементу, получить список новых значений.

listApply fs xs = concatMap (\f -> map f xs) fs

-- print $ listApply f x --> [11, 21, 31, 20, 40, 60]

-- Немного философии, почему для списков это логично делать именно так. Можно
-- считать, что Maybe - это вычисления, в которых иногда отсутствуют результаты.
-- А в списках можно считать, что мы делаем вычисления, в которых может быть несколько результатов.

-- В Haskell есть класс типов Аппликативные функторы:
class Functor' f => Applicative' f where
    pure :: a -> f a -- вставить значение в функтор
    (<*>) :: f (a -> b) -> f a -> f b -- та самая функция применения, рассмотренная выше
    -- и ещё несколько, см. дальше

-- pure - это функция, котора помещает значение внутрь функтора "самым естественным способом". Что это значит
-- будет понятно из требований к аппликативному функтору, см. дальше

-- для Maybe: pure x = Just x, для списка: pure x = [x]

-- Допустим, мы хотим сложить значения в двух Maybe.
-- Или в двух списках сложить попарно значения.
-- Как это будет написано?
x1 = Just 110
x2 = Just 654

-- надо сложить. Сначала давайте получим Just (+110), потом применим её к Just 654:
-- Останется как задача


