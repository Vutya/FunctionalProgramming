-- Ленивые вычисления
-- Вычисления совершаются только тогда, когда они нужны
-- loop = loop, сейчас тут тип любой, какой хотим (loop :: a)
-- loop :: a
-- loop = loop - зависает при вызове
-- вычислим 2 == 3 && loop, будет False, так как не вычисляем второй аргумент
-- 2 == 2 && loop зависнет
-- второй аргумент && не вычисляется, если первый ложь
-- short-circuit логиечские операторы
-- head [2, loop, loop] -> 2
-- [2 ,loop, loop] !! 1 -> зависнет
--
-- Haskell хранит не значения, а выражения, чтобы вычислять значение.
-- Когда происходит вычисления?
-- 1) при печати на экран
-- 2) аргумент встроенной арифметической операции (например, функция +)
-- 3) строгое применение (f $ x = f x; f $! x = f x, где x сначала вычислится)
-- 2,3 -> 4) у некоторых встроенны функций аргументы могут быть строгими, то есть вычисляться до применения
-- 5) data Pair a b = Pair a !b deriving Show - типа Tuple для двух элементов, но второй элемент строгий, будет вычисляться
-- 6) при pattern matching
--
-- Pair 2 3 - всё ОК
-- Pair (2 + loop) 3 - печатает просто Pair и зависает
-- Pair 2 (3 + loop) - зависает сразу
-- f :: Pair a b -> Pair [a] [b] - функция, которая просто берёт пару
-- f (Pair x y) = Pair [x] [y]
-- Из-за ленивости вычислений мы не можем добраться до момента зависания, надо придумать пример лучше :c
--
-- пример на пункт 6
-- f заменяет первый элемент списка на 0
-- 1) f :: [Int] -> [Int]
-- f (_:l) = 0:l
-- f [loop, 2, 3] -> [0, 2, 3] - не зависнет, так как loop не будет вычисляться
-- 2) fp :: [Int] -> [Int]
-- fp l@(0:_) = l
-- fp (_:l) = 0:l
-- зависнет, так как начнёт вычисляться loop
-- 
-- пример с isPrime
-- divsList считает только первые два делителя
-- isPrime n = (divsList n) !! 1 == n
-- [1, 5] - число 5 простое
-- [1, 2, 3, 6] - проверяем второй элемент, число 6 не простое 
--
-- Коротко про бесконечные структуры данных
-- ones :: [Int]
-- ones = 1:ones
-- Первый элемент - единица, это бесконечный список из единиц
-- 
-- Числа Фибоначчи в виде бесконечной последовательности
-- fib :: [Int]
-- fib = 1:1:(zipwith (+) fib (tail fib))
