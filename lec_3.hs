-- Карринг
-- s :: Int -> Int -> Int
-- s x y = x + y
-- s 2 3 -> 5
-- f = s 2 -> f - это Int -> Int
-- f 5 = 7
-- f - частичное приминение функции, f добавляет 2 к числу
--
-- Чуть более болезный пример
-- Вспомним map (a -> b) -> [a] -> [b]
-- g = map (\x -> x + 1) 
-- g [5, 6, 7] -> [6, 7, 8]
-- Теперь g - это увеличение элементов списка на единицу
-- 
-- Срезы
-- (-) Int -> Int -> Int
-- (1-)
-- (-1) - это две частично применённые функции
-- (1-) 5 -> -4
-- (-1) 5 -> 4
-- (++[5]) -> функция приписывания [5] в конец списка
--
-- removeEven - пример описания функции, удалить чётные из списка
-- removeEven :: [Int] -> [Int]
-- removeEven l = filter (\x -> mod x 2 /= 0) l
-- removeEven = filter (\x -> mod x 2 /= 0) - это следствие частичного применения
-- Можно убрать одинаковые применения в конце
-- 
-- Функция $ применение
-- f $ x работает как f x
-- что_применить $ к_чему_применить
-- ($) :: (a -> b) -> a -> b
-- ($) f x = f x -- f $ x
--
-- Как использовать:
-- вместо f (n-1) можно писать f $ (n-1)
-- fact n f = fact (n-1) (n*f)
-- или fact $ (n-1) $ (n*f)
-- ($1) - функция, которая применяет заданную функцию к единице
--
-- Функция . - композиция
-- Математика f(x) = sin(x), g(x) = x + 1
-- h1(x) = f(g(x)) = sin(x+1)
-- h2(x) = g(f(x)) = sin(x) + 1
-- h1 = f . g (на доске точечка выколотая)
-- h2 = g . f
-- Определим композицию
-- (.) :: (b -> c) -> (a -> b) -> (a -> c)
-- 1) (.) f g = p where p x = f (g x)
-- 2) (.) f g = \x f (g x)
-- 3) (.) f g x = f (g x) - это (b -> c) -> (a -> b) -> a -> c, самый короткий способ походу
-- Пример использования
-- (map $ (+1).length) $ ["abc", "x"]
-- map ((+1).length) ["abc", "x"]
--
-- Функции foldl, foldr
-- Это универсальная обработка списков, циклы
-- foldl - аккумулятор, список и операция, всё по списку идёт
-- foldl :: (b -> a -> b) -> b -> [a] -> b
-- операция -> аккумулятор
-- foldr :: (a -> b -> b) -> b -> [a] -> b
-- foldl (+) 0
-- вот так можно сделать sum
-- sum l = foldl (+) 0 l
-- sum = foldl (+) 0
-- Описать функцию map через foldl
-- map f = foldl (\a x -> a++[f x])
-- [] - начальный аккумулятор
-- foldl - хвостовая рекурсия, а foldr - нет
--
-- МОЖНО ПОПРОБОВАТЬ САМИМ НАПИСАТЬ ФОЛДЫ
